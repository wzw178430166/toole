1. 说说 var let  const  之间的区别？

1.1 var定义的变量会预解析，如果变量没有定义就直接使用的话，JavaScript会解析这个变量代码不会报错，只会输出undefined
1.2 var在循环中使用的时候，循环体外依然可以使用

let声明的变量的特点
let定义的变量不会预解析，必须先声明再使用，否则会报错
let不能定义已经定义过的变量
let是块级作用域，函数内部使用let定义后，对函数外部无影响

由于let是块级作用域，在循环绑定事件过程中let会在这个循环中生效，再次循环时let会重新定义生效

const声明的变量的特点：
const定义的变量不会预解析，必须先声明再使用，否则会报错
const定义的变量不允许修改
但是，在数组里面，const的值是允许被修改的，这是因为const存储的是地址，值的内容可以变化

最后说一点就是使用的场景说明：let一般应用于基本数据类型；const 一般应用于引用数据类型，也就是函数对象等

2.es6中数组新增的扩展有
Array.from()将类数组对象与可遍历的对象转化为数组并返回。
Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
2.扩展运算符（...）也可以将某些数据结构转为数组
3.Array.of方法用于将一组值，转换为数组。
4.数组实例的fill()
fill方法使用给定值，填充一个数组。
fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。
提供三个新的方法——entries()【N 团s】，keys()和values()——是用于遍历数组。

5.es6中对象新增了哪些扩展？
ES6允许字面量定义对象时，把表达式放在括号内。作为对象的属性名，表达式还可以用于定义方法名

属性的简洁表示法 ES6允许直接写入变量和函数，作为对象的属性和方法

注意：属性名表达式和简洁表示法，不能同时使用，会报错。
属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串

另外ES6一共有5种方法可以遍历对象的属性
for...in，Object.keys(obj)，Object.getOwnPropertyNames(obj)，Object.getOwnPropertySymbols(obj)，Reflect.ownKeys(obj)

ES6又新增了另一个类似的关键字super，指向当前对象的原型对象
还有Promise对象、对象解构、对象的扩展运算符 。。。

6. es6中函数新增了哪些扩展
 箭头函数
 函数的不定参数
 函数的扩展实参rest 参数
ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
rest必须是最后一个参数,否则会报错

严格模式
从 ES5 开始，函数内部可以设定为严格模式 , ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

name 属性
函数的name属性，返回该函数的函数名。

双冒号运算符
函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。

尾调用
什么是尾调用

尾调用是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。

7. 你是怎么理解es6中 promise的？ 使用场景？
在ajax请求数据的过程中，我们可以异步拿到我们想要的数据，然后在回调中做相应的数据处理。
但是如果这个时候，我们还需要做另外一个ajax请求，这个新的ajax请求的其中一个参数，要从上一个ajax请求中获取，这个时候我们就需要在回调函数中再写一个异步请求，然后在这个异步函数的回调函数里在写相应的数据处理，这样容易造成回调地狱。Promise 通过简单的链式调用就能得到多层回调才能达成的效果。promise可以支持多个并发的请求，获取并发请求中的数据，按顺序执行。


